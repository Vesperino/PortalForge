using MediatR;
using Microsoft.Extensions.Logging;
using PortalForge.Application.Exceptions;
using PortalForge.Application.Common.Interfaces;
using System.Text.RegularExpressions;

namespace PortalForge.Application.UseCases.News.Commands.CreateNews;

public class CreateNewsCommandHandler : IRequestHandler<CreateNewsCommand, int>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IUnifiedValidatorService _validatorService;
    private readonly ILogger<CreateNewsCommandHandler> _logger;

    public CreateNewsCommandHandler(
        IUnitOfWork unitOfWork,
        IUnifiedValidatorService validatorService,
        ILogger<CreateNewsCommandHandler> logger)
    {
        _unitOfWork = unitOfWork;
        _validatorService = validatorService;
        _logger = logger;
    }

    public async Task<int> Handle(CreateNewsCommand request, CancellationToken cancellationToken)
    {
        await _validatorService.ValidateAsync(request);

        _logger.LogInformation(
            "Creating news: {Title}, Category: {Category}, AuthorId: {AuthorId}",
            request.Title, request.Category, request.AuthorId);

        var author = await _unitOfWork.UserRepository.GetByIdAsync(request.AuthorId);
        if (author == null)
        {
            throw new NotFoundException($"Author with ID {request.AuthorId} not found");
        }

        if (request.EventId.HasValue)
        {
            var eventEntity = await _unitOfWork.EventRepository.GetByIdAsync(request.EventId.Value);
            if (eventEntity == null)
            {
                throw new NotFoundException($"Event with ID {request.EventId.Value} not found");
            }
        }

        // Parse category string to enum (validator already checked it's valid)
        var category = Enum.Parse<Domain.Entities.NewsCategory>(request.Category, ignoreCase: true);

        var news = new Domain.Entities.News
        {
            Title = request.Title,
            Content = request.Content,
            Excerpt = request.Excerpt,
            ImageUrl = request.ImageUrl,
            AuthorId = request.AuthorId,
            Category = category,
            EventId = request.EventId,
            CreatedAt = DateTime.UtcNow,
            Views = 0,
            IsEvent = request.IsEvent,
            EventHashtag = request.EventHashtag,
            EventDateTime = request.EventDateTime,
            EventLocation = request.EventLocation,
            EventPlaceId = request.EventPlaceId,
            EventLatitude = request.EventLatitude,
            EventLongitude = request.EventLongitude,
            DepartmentId = request.DepartmentId
        };

        // Handle hashtags - combine from request and auto-detect from content
        var allHashtags = await ProcessHashtagsAsync(request.Hashtags, request.Content);
        news.Hashtags = allHashtags;

        await _unitOfWork.NewsRepository.CreateAsync(news);
        await _unitOfWork.SaveChangesAsync();

        // ID is generated by the database after SaveChangesAsync()
        _logger.LogInformation("News created successfully with ID: {NewsId}", news.Id);

        return news.Id;
    }

    private async Task<List<Domain.Entities.Hashtag>> ProcessHashtagsAsync(List<string>? requestHashtags, string content)
    {
        var hashtagsFromRequest = requestHashtags ?? new List<string>();
        
        // Auto-detect hashtags from content using regex
        var hashtagPattern = @"(?:^|\s)(#[\w]+)";
        var matches = Regex.Matches(content, hashtagPattern);
        var hashtagsFromContent = matches.Select(m => m.Groups[1].Value).Distinct().ToList();

        // Combine both sources and remove duplicates (case-insensitive)
        var allHashtagNames = hashtagsFromRequest
            .Concat(hashtagsFromContent)
            .Select(h => h.StartsWith("#") ? h : $"#{h}")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (!allHashtagNames.Any())
        {
            return new List<Domain.Entities.Hashtag>();
        }

        // Get or create hashtags
        return await _unitOfWork.HashtagRepository.GetOrCreateHashtagsAsync(allHashtagNames);
    }
}
